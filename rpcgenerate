#!/usr/bin/python3.6

import subprocess
import json
import sys
import os

TODO = "\t" + "//TODO\n"
OPEN = "{\n"
CLOSE = "}\n"

def setup():
    filename, decls = parse_idl()
    filename = filename.split(".")[0]
    proxyname = filename + ".proxy.cpp"
    stubname = filename + ".stub.cpp"
    write_header(proxyname)
    write_header(stubname)
    write_proxy_fn(proxyname, decls)
    write_stub_fn(stubname, decls)

def parse_idl():
    IDL_TO_JSON_EXECUTABLE = './idl_to_json'
    try:
        # Make sure invoked properly
        if len(sys.argv) != 2:
            print("Wrong number of arguments", file=sys.stderr)
            raise Exception
        # Make sure IDL file exists and is readable
        filename = sys.argv[1]
        if (not os.path.isfile(filename)):
            print("Path %s does not designate a file" % filename, file=sys.stderr)
            raise Exception
        if (not os.access(filename, os.R_OK)):
            print("File %s is not readable" % filename, file=sys.stderr)
            raise Exception 
        # Make sure idl_to_json exists and is executable
        if (not os.path.isfile(IDL_TO_JSON_EXECUTABLE)):
            print("Path %s does not designate a file...run \"make\" to create it" % 
                IDL_TO_JSON_EXECUTABLE, file=sys.stderr)
            raise Exception
        if (not os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK)):
            print("File %s exists but is not executable" % 
                IDL_TO_JSON_EXECUTABLE, file=sys.stderr)
            raise Exception
        # Parse declarations into a Python dictionary
        decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]).decode('utf-8'))
        return filename, decls
    except Exception as e:
        print("Usage: %s <idlfilename>" % sys.argv[0], file=sys.stderr)
        print(e)

"""
Writes header text to file, creating the file if
it doesn't exist, overwriting the file if it already
exists.
"""
def write_header(filename):
    header = "//"+filename+"\n//authors: Jialu Wei, Remmy Chen\n"
    includes = "#include <string>\nusing namespace std;\n#include \"strings.idl\"\n#include \"rpcproxyhelper.h\"\n#include <cstdio>\n#include <cstring>\n#include \"c150debug.h\"\n#include <iostream>\n#include <vector>\nusing namespace C150NETWORK;\n"
    defines = "#define BUFSIZE 1024\n"
    with open(filename, 'w+') as f:
        f.write('%s\n' % header)
        f.write('%s\n' % includes)
        f.write('%s\n' % defines)
        f.close()

"""
Appends function contract skeletons to file.
"""
def write_proxy_fn(filename, decls):
    with open(filename, 'a+') as f:
        for name, sig in decls["functions"].items():
            args = sig["arguments"]
            argstring = ', '.join([a["type"] + ' ' + a["name"] for a in args])
            fnskeleton = sig["return_type"] + " " + name + "(" + argstring + ") " + OPEN + TODO + CLOSE
            f.write('%s\n' % fnskeleton)
    f.close()


"""
Appends function contract skeletons to file.
"""
def write_stub_fn(filename, decls):
    with open(filename, 'a+') as f:
        for name, sig in decls["functions"].items():
            args = sig["arguments"]
            argstring = ', '.join([a["type"] + ' ' + a["name"] for a in args])
            argnamestring = ', '.join([a["name"] for a in args])
            fncall = "\t" + sig["return_type"] + " res = " + name + "(" + argnamestring + ");\n"
            fnskeleton = "void __" + name + "(" + argstring + ") " + OPEN + fncall + TODO + CLOSE
            f.write('%s\n' % fnskeleton)
        dispatchfn = "void dispatchFunction() " + OPEN + TODO + CLOSE
        f.write('%s\n' % dispatchfn)
    f.close()


if __name__ == "__main__":
    setup()




